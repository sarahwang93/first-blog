import { __decorate } from "tslib";
import { Inject, Injectable, isDevMode } from '@angular/core';
import { Observable, Subject, combineLatest, from } from 'rxjs';
import { take } from 'rxjs/operators';
import { createTransaction, optionsGenerator, validateBeforeTransaction } from '../utils';
import { CloseDbConnection } from './decorators';
import { CreateObjectStore, DeleteObjectStore, openDatabase } from './ngx-indexed-db';
import { CONFIG_TOKEN, DBMode, INDEXED_DB, } from './ngx-indexed-db.meta';
import * as i0 from "@angular/core";
export class NgxIndexedDBService {
    constructor(dbConfigs, indexedDB) {
        this.dbConfigs = dbConfigs;
        this.indexedDB = indexedDB;
        this.defaultDatabaseName = null;
        Object.values(this.dbConfigs).forEach((dbConfig, _, ref) => this.instanciateConfig(dbConfig, ref.length === 1));
    }
    async instanciateConfig(dbConfig, isOnlyConfig) {
        if (!dbConfig.name) {
            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');
        }
        if (!dbConfig.version) {
            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');
        }
        if ((dbConfig.isDefault ?? false) && this.defaultDatabaseName) {
            // A default DB is already configured, throw an error
            throw new Error('NgxIndexedDB: Only one database can be set as default');
        }
        if (((dbConfig.isDefault ?? false) && !this.defaultDatabaseName) || isOnlyConfig) {
            this.defaultDatabaseName = dbConfig.name;
            this.selectedDb = dbConfig.name;
        }
        await CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);
        openDatabase(this.indexedDB, dbConfig.name).then((db) => {
            if (db.version !== dbConfig.version) {
                if (isDevMode()) {
                    console.warn(`
            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it
            DB current version: ${db.version};
            Your configuration: ${dbConfig.version};
            `);
                    console.warn(`Using latest version ${db.version}`);
                }
                this.dbConfigs[dbConfig.name].version = db.version;
            }
            db.close();
        });
    }
    get dbConfig() {
        return this.dbConfigs[this.selectedDb];
    }
    /**
     * The function return the current version of database
     *
     * @Return the current version of database as number
     */
    getDatabaseVersion() {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                obs.next(db.version);
                obs.complete();
            })
                .catch((err) => obs.error(`error during get version of database => ${err} `));
        });
    }
    /**
     * Selects a database for the current context.
     * @param {string} [databaseName=undefined] Database name to select.
     */
    selectDb(databaseName) {
        databaseName = databaseName ?? this.defaultDatabaseName;
        if (!databaseName) {
            // Name is still null, it means that there is no default database set
            // and the database name was not specified while calling a method
            throw new Error(`No database name specified and no default database set.`);
        }
        if (!Object.keys(this.dbConfigs).includes(databaseName)) {
            throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);
        }
        this.selectedDb = databaseName;
    }
    /**
     * Allows to create a new object store ad-hoc
     * @param storeName The name of the store to be created
     * @param migrationFactory The migration factory if exists
     */
    async createObjectStore(storeSchema, migrationFactory) {
        const storeSchemas = [storeSchema];
        await CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);
    }
    /**
     * Adds new entry in the store and returns its key
     * @param storeName The name of the store to add the item
     * @param value The entry to be added
     * @param key The optional key for the entry
     */
    add(storeName, value, key) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);
                request.onsuccess = async (evt) => {
                    const result = evt.target.result;
                    const getRequest = objectStore.get(result);
                    getRequest.onsuccess = (event) => {
                        obs.next(event.target.result);
                        obs.complete();
                    };
                    getRequest.onerror = (event) => {
                        obs.error(event);
                    };
                };
                request.onerror = (event) => {
                    obs.error(event);
                };
            })
                .catch((error) => obs.error(error));
        });
    }
    /**
     * Adds new entries in the store and returns its key
     * @param storeName The name of the store to add the item
     * @param values The entries to be added containing optional key attribute
     */
    bulkAdd(storeName, values) {
        const promises = new Promise((resolve, reject) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));
                const objectStore = transaction.objectStore(storeName);
                const results = values.map((value) => {
                    return new Promise((resolve1, reject1) => {
                        const key = value.key;
                        delete value.key;
                        const request = Boolean(key)
                            ? objectStore.add(value, key)
                            : objectStore.add(value);
                        request.onsuccess = (evt) => {
                            const result = evt.target.result;
                            resolve1(result);
                        };
                    });
                });
                resolve(Promise.all(results));
            })
                .catch((reason) => reject(reason));
        });
        return from(promises);
    }
    /**
     * Delete entries in the store and returns current entries in the store
     * @param storeName The name of the store to add the item
     * @param keys The keys to be deleted
     */
    bulkDelete(storeName, keys) {
        const promises = keys.map((key) => {
            return new Promise((resolve, reject) => {
                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                    .then((db) => {
                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));
                    const objectStore = transaction.objectStore(storeName);
                    objectStore.delete(key);
                    transaction.oncomplete = () => {
                        this.getAll(storeName)
                            .pipe(take(1))
                            .subscribe((newValues) => {
                            resolve(newValues);
                        });
                    };
                })
                    .catch((reason) => reject(reason));
            });
        });
        return from(Promise.all(promises));
    }
    /**
     * Returns entry by key.
     * @param storeName The name of the store to query
     * @param key The entry key
     */
    getByKey(storeName, key) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.get(key);
                request.onsuccess = (event) => {
                    obs.next(event.target.result);
                    obs.complete();
                };
                request.onerror = (event) => {
                    obs.error(event);
                };
            })
                .catch((error) => obs.error(error));
        });
    }
    /**
     * Retrieve multiple entries in the store
     * @param storeName The name of the store to retrieve the items
     * @param keys The ids entries to be retrieve
     */
    bulkGet(storeName, keys) {
        const observables = keys.map((key) => this.getByKey(storeName, key));
        return new Observable((obs) => {
            combineLatest(observables).subscribe((values) => {
                obs.next(values);
                obs.complete();
            });
        });
    }
    /**
     * Returns entry by id.
     * @param storeName The name of the store to query
     * @param id The entry id
     */
    getByID(storeName, id) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.get(id);
                request.onsuccess = (event) => {
                    obs.next(event.target.result);
                };
            })
                .catch((error) => obs.error(error));
        });
    }
    /**
     * Returns entry by index.
     * @param storeName The name of the store to query
     * @param indexName The index name to filter
     * @param key The entry key.
     */
    getByIndex(storeName, indexName, key) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const index = objectStore.index(indexName);
                const request = index.get(key);
                request.onsuccess = (event) => {
                    obs.next(event.target.result);
                    obs.complete();
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Return all elements from one store
     * @param storeName The name of the store to select the items
     */
    getAll(storeName) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.getAll();
                request.onerror = (evt) => {
                    obs.error(evt);
                };
                request.onsuccess = ({ target: { result: ResultAll } }) => {
                    obs.next(ResultAll);
                    obs.complete();
                };
            })
                .catch((error) => obs.error(error));
        });
    }
    /**
     * Adds or updates a record in store with the given value and key. Return all items present in the store
     * @param storeName The name of the store to update
     * @param value The new value for the entry
     */
    update(storeName, value) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.put(value);
                request.onsuccess = async (evt) => {
                    const result = evt.target.result;
                    const getRequest = objectStore.get(result);
                    getRequest.onsuccess = (event) => {
                        obs.next(event.target.result);
                        obs.complete();
                    };
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Adds or updates a record in store with the given value and key. Return all items present in the store
     * @param storeName The name of the store to update
     * @param items The values to update in the DB
     *
     * @Return The return value is an Observable with the primary key of the object that was last in given array
     *
     * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted
     */
    bulkPut(storeName, items) {
        let transaction;
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                items.forEach((item, index) => {
                    const request = objectStore.put(item);
                    if (index === items.length - 1) {
                        request.onsuccess = (evt) => {
                            transaction.commit();
                            obs.next(evt.target.result);
                            obs.complete();
                        };
                    }
                    request.onerror = (evt) => {
                        transaction.abort();
                        obs.error(evt);
                    };
                });
            })
                .catch((reason) => {
                transaction?.abort();
                obs.error(reason);
            });
        });
    }
    /**
     * Returns all items from the store after delete.
     * @param storeName The name of the store to have the entry deleted
     * @param key The key of the entry to be deleted
     */
    delete(storeName, key) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                objectStore.delete(key);
                transaction.oncomplete = () => {
                    this.getAll(storeName)
                        .pipe(take(1))
                        .subscribe((newValues) => {
                        obs.next(newValues);
                        obs.complete();
                    });
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns true from the store after a successful delete.
     * @param storeName The name of the store to have the entry deleted
     * @param key The key of the entry to be deleted
     */
    deleteByKey(storeName, key) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                transaction.oncomplete = () => {
                    obs.next(true);
                    obs.complete();
                };
                objectStore.delete(key);
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns true if successfully delete all entries from the store.
     * @param storeName The name of the store to have the entries deleted
     */
    clear(storeName) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));
                const objectStore = transaction.objectStore(storeName);
                objectStore.clear();
                transaction.oncomplete = () => {
                    obs.next(true);
                    obs.complete();
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns true if successfully delete the DB.
     */
    deleteDatabase() {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then(async (db) => {
                await db.close();
                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);
                deleteDBRequest.onsuccess = () => {
                    obs.next(true);
                    obs.complete();
                };
                deleteDBRequest.onerror = (error) => obs.error(error);
                deleteDBRequest.onblocked = () => {
                    console.warn('Delete blocked: Ensure all tabs, instances, or connections are closed. Database name:', this.dbConfig.name);
                    obs.error(new Error("Unable to delete database because it's blocked"));
                };
            })
                .catch((error) => obs.error(error));
        });
    }
    /**
     * Returns the open cursor event
     * @param storeName The name of the store to have the entries deleted
     * @param keyRange The key range which the cursor should be open on
     * @param direction A string telling the cursor which direction to travel. The default is next
     */
    openCursor(storeName, keyRange, direction = 'next') {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange, direction);
                request.onsuccess = (event) => {
                    obs.next(event);
                    obs.complete();
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Open a cursor by index filter.
     * @param storeName The name of the store to query.
     * @param indexName The index name to filter.
     * @param keyRange The range value and criteria to apply on the index.
     */
    openCursorByIndex(storeName, indexName, keyRange, direction = 'next', mode = DBMode.readonly) {
        const obs = new Subject();
        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
            .then((db) => {
            validateBeforeTransaction(db, storeName, (reason) => {
                obs.error(reason);
            });
            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {
                obs.error(reason);
            }, () => {
                obs.next();
            }));
            const objectStore = transaction.objectStore(storeName);
            const index = objectStore.index(indexName);
            const request = index.openCursor(keyRange, direction);
            request.onsuccess = (event) => {
                obs.next(event);
            };
        })
            .catch((reason) => obs.error(reason));
        return obs;
    }
    /**
     * Returns all items by an index.
     * @param storeName The name of the store to query
     * @param indexName The index name to filter
     * @param keyRange  The range value and criteria to apply on the index.
     */
    getAllByIndex(storeName, indexName, keyRange) {
        const data = [];
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const index = objectStore.index(indexName);
                const request = index.openCursor(keyRange);
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        data.push(cursor.value);
                        cursor.continue();
                    }
                    else {
                        obs.next(data);
                        obs.complete();
                    }
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns all primary keys by an index.
     * @param storeName The name of the store to query
     * @param indexName The index name to filter
     * @param keyRange  The range value and criteria to apply on the index.
     */
    getAllKeysByIndex(storeName, indexName, keyRange) {
        const data = [];
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const index = objectStore.index(indexName);
                const request = index.openKeyCursor(keyRange);
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });
                        cursor.continue();
                    }
                    else {
                        obs.next(data);
                        obs.complete();
                    }
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns the number of rows in a store.
     * @param storeName The name of the store to query
     * @param keyRange  The range value and criteria to apply.
     */
    count(storeName, keyRange) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.count(keyRange);
                request.onerror = (e) => obs.error(e);
                request.onsuccess = (e) => {
                    obs.next(e.target.result);
                    obs.complete();
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Returns the number of rows in a store.
     * @param storeName The name of the store to query
     * @param keyRange  The range value and criteria to apply.
     */
    countByIndex(storeName, indexName, keyRange) {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                validateBeforeTransaction(db, storeName, (e) => obs.error(e));
                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));
                const objectStore = transaction.objectStore(storeName);
                const index = objectStore.index(indexName);
                const request = index.count(keyRange);
                request.onerror = (e) => obs.error(e);
                request.onsuccess = (e) => {
                    obs.next(e.target.result);
                    obs.complete();
                };
            })
                .catch((reason) => obs.error(reason));
        });
    }
    /**
     * Delete the store by name.
     * @param storeName The name of the store to query
     */
    deleteObjectStore(storeName) {
        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);
    }
    /**
     * Get all object store names.
     */
    getAllObjectStoreNames() {
        return new Observable((obs) => {
            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)
                .then((db) => {
                obs.next([...db.objectStoreNames]);
                obs.complete();
            })
                .catch((reason) => obs.error(reason));
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: INDEXED_DB }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgxIndexedDBService }); }
}
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getDatabaseVersion", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "add", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "bulkAdd", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "bulkDelete", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getByKey", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "bulkGet", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getByID", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getByIndex", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getAll", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "update", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "bulkPut", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "delete", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "deleteByKey", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "clear", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "deleteDatabase", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "openCursor", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "openCursorByIndex", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getAllByIndex", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getAllKeysByIndex", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "count", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "countByIndex", null);
__decorate([
    CloseDbConnection()
], NgxIndexedDBService.prototype, "getAllObjectStoreNames", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: NgxIndexedDBService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [CONFIG_TOKEN]
                }] }, { type: IDBFactory, decorators: [{
                    type: Inject,
                    args: [INDEXED_DB]
                }] }], propDecorators: { getDatabaseVersion: [], add: [], bulkAdd: [], bulkDelete: [], getByKey: [], bulkGet: [], getByID: [], getByIndex: [], getAll: [], update: [], bulkPut: [], delete: [], deleteByKey: [], clear: [], deleteDatabase: [], openCursor: [], openCursorByIndex: [], getAllByIndex: [], getAllKeysByIndex: [], count: [], countByIndex: [], getAllObjectStoreNames: [] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWluZGV4ZWQtZGIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1pbmRleGVkLWRiL3NyYy9saWIvbmd4LWluZGV4ZWQtZGIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlELE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFjLGFBQWEsRUFBRSxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSx5QkFBeUIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMxRixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDakQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RGLE9BQU8sRUFDTCxZQUFZLEVBRVosTUFBTSxFQUNOLFVBQVUsR0FLWCxNQUFNLHVCQUF1QixDQUFDOztBQUcvQixNQUFNLE9BQU8sbUJBQW1CO0lBSTlCLFlBQ2dDLFNBQW1DLEVBQ3JDLFNBQXFCO1FBRG5CLGNBQVMsR0FBVCxTQUFTLENBQTBCO1FBQ3JDLGNBQVMsR0FBVCxTQUFTLENBQVk7UUFMM0Msd0JBQW1CLEdBQVksSUFBSSxDQUFDO1FBTzFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsSCxDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQWtCLEVBQUUsWUFBcUI7UUFDdkUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLCtEQUErRCxDQUFDLENBQUM7UUFDbkYsQ0FBQztRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDO1FBQ3ZGLENBQUM7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUM5RCxxREFBcUQ7WUFDckQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksWUFBWSxFQUFFLENBQUM7WUFDakYsSUFBSSxDQUFDLG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7WUFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQ2xDLENBQUM7UUFFRCxNQUFNLGlCQUFpQixDQUNyQixJQUFJLENBQUMsU0FBUyxFQUNkLFFBQVEsQ0FBQyxJQUFJLEVBQ2IsUUFBUSxDQUFDLE9BQU8sRUFDaEIsUUFBUSxDQUFDLGdCQUFnQixFQUN6QixRQUFRLENBQUMsZ0JBQWdCLENBQzFCLENBQUM7UUFFRixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7WUFDdEQsSUFBSSxFQUFFLENBQUMsT0FBTyxLQUFLLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDcEMsSUFBSSxTQUFTLEVBQUUsRUFBRSxDQUFDO29CQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDO3VGQUNnRSxRQUFRLENBQUMsSUFBSTtrQ0FDbEUsRUFBRSxDQUFDLE9BQU87a0NBQ1YsUUFBUSxDQUFDLE9BQU87YUFDckMsQ0FBQyxDQUFDO29CQUNMLE9BQU8sQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2dCQUNyRCxDQUFDO2dCQUNELElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDO1lBQ3JELENBQUM7WUFFRCxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDYixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxJQUFZLFFBQVE7UUFDbEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVILGtCQUFrQjtRQUNoQixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQWUsRUFBRSxFQUFFO2dCQUN4QixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckIsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pCLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsMkNBQTJDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsRixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSSxRQUFRLENBQUMsWUFBcUI7UUFDbkMsWUFBWSxHQUFHLFlBQVksSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDeEQsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ2xCLHFFQUFxRTtZQUNyRSxpRUFBaUU7WUFDakUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO1FBQzdFLENBQUM7UUFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUM7WUFDeEQsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsWUFBWSxzQkFBc0IsQ0FBQyxDQUFDO1FBQ2hGLENBQUM7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFlBQVksQ0FBQztJQUNqQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxpQkFBaUIsQ0FDckIsV0FBNEIsRUFDNUIsZ0JBQWtHO1FBRWxHLE1BQU0sWUFBWSxHQUFzQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3RELE1BQU0saUJBQWlCLENBQ3JCLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQ2xCLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQ3ZCLFlBQVksRUFDWixnQkFBZ0IsQ0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUVILEdBQUcsQ0FBSSxTQUFpQixFQUFFLEtBQVEsRUFBRSxHQUFTO1FBQzNDLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBZSxFQUFFLEVBQUU7Z0JBQ3hCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUNuQyxFQUFFLEVBQ0YsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDbkUsQ0FBQztnQkFDRixNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLE9BQU8sR0FBNEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFN0csT0FBTyxDQUFDLFNBQVMsR0FBRyxLQUFLLEVBQUUsR0FBVSxFQUFFLEVBQUU7b0JBQ3ZDLE1BQU0sTUFBTSxHQUFTLEdBQUcsQ0FBQyxNQUEyQixDQUFDLE1BQU0sQ0FBQztvQkFDNUQsTUFBTSxVQUFVLEdBQWUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQWtCLENBQUM7b0JBQ3hFLFVBQVUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRTt3QkFDdEMsR0FBRyxDQUFDLElBQUksQ0FBRSxLQUFLLENBQUMsTUFBaUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDMUQsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNqQixDQUFDLENBQUM7b0JBRUYsVUFBVSxDQUFDLE9BQU8sR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFO3dCQUNwQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNuQixDQUFDLENBQUM7Z0JBQ0osQ0FBQyxDQUFDO2dCQUVGLE9BQU8sQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRTtvQkFDakMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbkIsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxPQUFPLENBQUksU0FBaUIsRUFBRSxNQUFnQztRQUM1RCxNQUFNLFFBQVEsR0FBRyxJQUFJLE9BQU8sQ0FBVyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUN6RCxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBZSxFQUFFLEVBQUU7Z0JBQ3hCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDMUcsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFdkQsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO29CQUNuQyxPQUFPLElBQUksT0FBTyxDQUFTLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxFQUFFO3dCQUMvQyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO3dCQUN0QixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUM7d0JBRWpCLE1BQU0sT0FBTyxHQUE0QixPQUFPLENBQUMsR0FBRyxDQUFDOzRCQUNuRCxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDOzRCQUM3QixDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFFM0IsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQVUsRUFBRSxFQUFFOzRCQUNqQyxNQUFNLE1BQU0sR0FBSSxHQUFHLENBQUMsTUFBMkIsQ0FBQyxNQUFNLENBQUM7NEJBQ3ZELFFBQVEsQ0FBRSxNQUE0QixDQUFDLENBQUM7d0JBQzFDLENBQUMsQ0FBQztvQkFDSixDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFFSCxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxVQUFVLENBQUMsU0FBaUIsRUFBRSxJQUFXO1FBQ3ZDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNoQyxPQUFPLElBQUksT0FBTyxDQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO2dCQUM3QyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztxQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBZSxFQUFFLEVBQUU7b0JBQ3hCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztvQkFDMUcsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDdkQsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFFeEIsV0FBVyxDQUFDLFVBQVUsR0FBRyxHQUFHLEVBQUU7d0JBQzVCLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDOzZCQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOzZCQUNiLFNBQVMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFOzRCQUN2QixPQUFPLENBQUMsU0FBZ0IsQ0FBQyxDQUFDO3dCQUM1QixDQUFDLENBQUMsQ0FBQztvQkFDUCxDQUFDLENBQUM7Z0JBQ0osQ0FBQyxDQUFDO3FCQUNELEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDdkMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVILFFBQVEsQ0FBSSxTQUFpQixFQUFFLEdBQWdCO1FBQzdDLE9BQU8sSUFBSSxVQUFVLENBQUksQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUMvQixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBZSxFQUFFLEVBQUU7Z0JBQ3hCLE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDbkcsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkQsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQWtCLENBQUM7Z0JBQ3RELE9BQU8sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRTtvQkFDbkMsR0FBRyxDQUFDLElBQUksQ0FBRSxLQUFLLENBQUMsTUFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDakQsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNqQixDQUFDLENBQUM7Z0JBQ0YsT0FBTyxDQUFDLE9BQU8sR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFO29CQUNqQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNuQixDQUFDLENBQUM7WUFDSixDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVILE9BQU8sQ0FBSSxTQUFpQixFQUFFLElBQXdCO1FBQ3BELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUksU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFeEUsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzVCLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQkFDOUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDakIsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVILE9BQU8sQ0FBSSxTQUFpQixFQUFFLEVBQW1CO1FBQy9DLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBZSxFQUFFLEVBQUU7Z0JBQ3hCLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQzdHLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3ZELE1BQU0sT0FBTyxHQUFlLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFrQixDQUFDO2dCQUNqRSxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUU7b0JBQ25DLEdBQUcsQ0FBQyxJQUFJLENBQUUsS0FBSyxDQUFDLE1BQXdCLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ25ELENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUVILFVBQVUsQ0FBSSxTQUFpQixFQUFFLFNBQWlCLEVBQUUsR0FBZ0I7UUFDbEUsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzVCLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO2lCQUNwRSxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtnQkFDWCx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlELE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDbkcsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQWtCLENBQUM7Z0JBQ2hELE9BQU8sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxLQUFZLEVBQUUsRUFBRTtvQkFDbkMsR0FBRyxDQUFDLElBQUksQ0FBRSxLQUFLLENBQUMsTUFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDakQsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNqQixDQUFDLENBQUM7WUFDSixDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBRUgsTUFBTSxDQUFJLFNBQWlCO1FBQ3pCLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ1gseUJBQXlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDN0csTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFdkQsTUFBTSxPQUFPLEdBQWUsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUVqRCxPQUFPLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7b0JBQy9CLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQztnQkFFRixPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQW1CLEVBQUUsRUFBRTtvQkFDekUsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFnQixDQUFDLENBQUM7b0JBQzNCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDakIsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxNQUFNLENBQUksU0FBaUIsRUFBRSxLQUFRO1FBQ25DLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ1gseUJBQXlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FDbkMsRUFBRSxFQUNGLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ25FLENBQUM7Z0JBQ0YsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFdkQsTUFBTSxPQUFPLEdBQTRCLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBRWhFLE9BQU8sQ0FBQyxTQUFTLEdBQUcsS0FBSyxFQUFFLEdBQVUsRUFBRSxFQUFFO29CQUN2QyxNQUFNLE1BQU0sR0FBUyxHQUFHLENBQUMsTUFBMkIsQ0FBQyxNQUFNLENBQUM7b0JBRTVELE1BQU0sVUFBVSxHQUFlLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFrQixDQUFDO29CQUN4RSxVQUFVLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUU7d0JBQ3RDLEdBQUcsQ0FBQyxJQUFJLENBQUUsS0FBSyxDQUFDLE1BQWlDLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQzFELEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDakIsQ0FBQyxDQUFDO2dCQUNKLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUVJLE9BQU8sQ0FBSSxTQUFpQixFQUFFLEtBQWU7UUFDbEQsSUFBSSxXQUEyQixDQUFDO1FBQ2hDLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ1gseUJBQXlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5RCxXQUFXLEdBQUcsaUJBQWlCLENBQzdCLEVBQUUsRUFDRixnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNuRSxDQUFDO2dCQUNGLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBRXZELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBYSxFQUFFLEVBQUU7b0JBQ3BDLE1BQU0sT0FBTyxHQUE0QixXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUUvRCxJQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO3dCQUMvQixPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7NEJBQ2pDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs0QkFDckIsR0FBRyxDQUFDLElBQUksQ0FBRSxHQUFHLENBQUMsTUFBMEIsQ0FBQyxNQUFNLENBQUMsQ0FBQzs0QkFDakQsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO3dCQUNqQixDQUFDLENBQUM7b0JBQ0osQ0FBQztvQkFFRCxPQUFPLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7d0JBQy9CLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt3QkFDcEIsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDakIsQ0FBQyxDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUNoQixXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUM7Z0JBQ3JCLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEIsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBRUgsTUFBTSxDQUFJLFNBQWlCLEVBQUUsR0FBUTtRQUNuQyxPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUNYLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQ25DLEVBQUUsRUFDRixnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNuRSxDQUFDO2dCQUNGLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3ZELFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBRXhCLFdBQVcsQ0FBQyxVQUFVLEdBQUcsR0FBRyxFQUFFO29CQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQzt5QkFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDYixTQUFTLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRTt3QkFDdkIsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFnQixDQUFDLENBQUM7d0JBQzNCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDakIsQ0FBQyxDQUFDLENBQUM7Z0JBQ1AsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxXQUFXLENBQUMsU0FBaUIsRUFBRSxHQUFRO1FBQ3JDLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ1gseUJBQXlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FDbkMsRUFBRSxFQUNGLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ25FLENBQUM7Z0JBQ0YsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFdkQsV0FBVyxDQUFDLFVBQVUsR0FBRyxHQUFHLEVBQUU7b0JBQzVCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ2YsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNqQixDQUFDLENBQUM7Z0JBRUYsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMxQixDQUFDLENBQUM7aUJBQ0QsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDMUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBRUgsS0FBSyxDQUFDLFNBQWlCO1FBQ3JCLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUM1QixZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7Z0JBQ1gseUJBQXlCLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM5RCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FDbkMsRUFBRSxFQUNGLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ25FLENBQUM7Z0JBQ0YsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkQsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNwQixXQUFXLENBQUMsVUFBVSxHQUFHLEdBQUcsRUFBRTtvQkFDNUIsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZixHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUVILGNBQWM7UUFDWixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUU7Z0JBQ2pCLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNqQixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMxRSxlQUFlLENBQUMsU0FBUyxHQUFHLEdBQUcsRUFBRTtvQkFDL0IsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDZixHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQztnQkFDRixlQUFlLENBQUMsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUN0RCxlQUFlLENBQUMsU0FBUyxHQUFHLEdBQUcsRUFBRTtvQkFDL0IsT0FBTyxDQUFDLElBQUksQ0FDVix1RkFBdUYsRUFDdkYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ25CLENBQUM7b0JBQ0YsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pFLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUVILFVBQVUsQ0FBQyxTQUFpQixFQUFFLFFBQXNCLEVBQUUsWUFBZ0MsTUFBTTtRQUMxRixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUNYLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNwRyxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLE9BQU8sR0FDWCxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUVsRyxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUU7b0JBQ25DLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2hCLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDakIsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBRUgsaUJBQWlCLENBQ2YsU0FBaUIsRUFDakIsU0FBaUIsRUFDakIsUUFBcUIsRUFDckIsWUFBZ0MsTUFBTSxFQUN0QyxPQUFlLE1BQU0sQ0FBQyxRQUFRO1FBRTlCLE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxFQUFTLENBQUM7UUFFakMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7YUFDcEUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7WUFDWCx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ2xELEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEIsQ0FBQyxDQUFDLENBQUM7WUFDSCxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FDbkMsRUFBRSxFQUNGLGdCQUFnQixDQUNkLElBQUksRUFDSixTQUFTLEVBQ1QsQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQkFDVCxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3BCLENBQUMsRUFDRCxHQUFHLEVBQUU7Z0JBQ0gsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2IsQ0FBQyxDQUNGLENBQ0YsQ0FBQztZQUNGLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDdkQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMzQyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUV0RCxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBWSxFQUFFLEVBQUU7Z0JBQ25DLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbEIsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDO2FBQ0QsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFeEMsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFFSCxhQUFhLENBQUksU0FBaUIsRUFBRSxTQUFpQixFQUFFLFFBQXFCO1FBQzFFLE1BQU0sSUFBSSxHQUFRLEVBQUUsQ0FBQztRQUNyQixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUNYLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNuRyxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUMzQyxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQzVCLE1BQU0sTUFBTSxHQUF3QixLQUFLLENBQUMsTUFBeUMsQ0FBQyxNQUFNLENBQUM7b0JBQzNGLElBQUksTUFBTSxFQUFFLENBQUM7d0JBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ3hCLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDcEIsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ2YsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNqQixDQUFDO2dCQUNILENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUVILGlCQUFpQixDQUNmLFNBQWlCLEVBQ2pCLFNBQWlCLEVBQ2pCLFFBQXFCO1FBRXJCLE1BQU0sSUFBSSxHQUFvQyxFQUFFLENBQUM7UUFDakQsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzVCLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO2lCQUNwRSxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtnQkFDWCx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlELE1BQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDbkcsTUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDOUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFO29CQUM1QixNQUFNLE1BQU0sR0FBZSxLQUFLLENBQUMsTUFBZ0MsQ0FBQyxNQUFNLENBQUM7b0JBQ3pFLElBQUksTUFBTSxFQUFFLENBQUM7d0JBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQzt3QkFDOUQsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNwQixDQUFDO3lCQUFNLENBQUM7d0JBQ04sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDZixHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ2pCLENBQUM7Z0JBQ0gsQ0FBQyxDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFFSCxLQUFLLENBQUMsU0FBaUIsRUFBRSxRQUFvQztRQUMzRCxPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUNYLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNuRyxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLE9BQU8sR0FBZSxXQUFXLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN4RCxPQUFPLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hCLEdBQUcsQ0FBQyxJQUFJLENBQUcsQ0FBQyxDQUFDLE1BQTJCLENBQUMsTUFBNEIsQ0FBQyxDQUFDO29CQUN2RSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBRUgsWUFBWSxDQUFDLFNBQWlCLEVBQUUsU0FBaUIsRUFBRSxRQUFvQztRQUNyRixPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUIsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFO2dCQUNYLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNuRyxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLE9BQU8sR0FBZSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNsRCxPQUFPLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUU7b0JBQ3hCLEdBQUcsQ0FBQyxJQUFJLENBQUcsQ0FBQyxDQUFDLE1BQTJCLENBQUMsTUFBNEIsQ0FBQyxDQUFDO29CQUN2RSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSCxpQkFBaUIsQ0FBQyxTQUFpQjtRQUNqQyxPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQUVEOztPQUVHO0lBRUgsc0JBQXNCO1FBQ3BCLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUF5QixFQUFRLEVBQUU7WUFDeEQsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLEVBQWUsRUFBUSxFQUFFO2dCQUM5QixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBSyxFQUFFLENBQUMsZ0JBQWlELENBQUMsQ0FBQyxDQUFDO2dCQUN0RSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakIsQ0FBQyxDQUFDO2lCQUNELEtBQUssQ0FBQyxDQUFDLE1BQWUsRUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzsrR0E3dEJVLG1CQUFtQixrQkFLcEIsWUFBWSxhQUNaLFVBQVU7bUhBTlQsbUJBQW1COztBQThEOUI7SUFEQyxpQkFBaUIsRUFBRTs2REFVbkI7QUE4Q0Q7SUFEQyxpQkFBaUIsRUFBRTs4Q0ErQm5CO0FBUUQ7SUFEQyxpQkFBaUIsRUFBRTtrREE4Qm5CO0FBUUQ7SUFEQyxpQkFBaUIsRUFBRTtxREFzQm5CO0FBUUQ7SUFEQyxpQkFBaUIsRUFBRTttREFrQm5CO0FBUUQ7SUFEQyxpQkFBaUIsRUFBRTtrREFVbkI7QUFRRDtJQURDLGlCQUFpQixFQUFFO2tEQWVuQjtBQVNEO0lBREMsaUJBQWlCLEVBQUU7cURBaUJuQjtBQU9EO0lBREMsaUJBQWlCLEVBQUU7aURBc0JuQjtBQVFEO0lBREMsaUJBQWlCLEVBQUU7aURBMEJuQjtBQVlNO0lBRE4saUJBQWlCLEVBQUU7a0RBbUNuQjtBQVFEO0lBREMsaUJBQWlCLEVBQUU7aURBd0JuQjtBQVFEO0lBREMsaUJBQWlCLEVBQUU7c0RBcUJuQjtBQU9EO0lBREMsaUJBQWlCLEVBQUU7Z0RBbUJuQjtBQU1EO0lBREMsaUJBQWlCLEVBQUU7eURBc0JuQjtBQVNEO0lBREMsaUJBQWlCLEVBQUU7cURBa0JuQjtBQVNEO0lBREMsaUJBQWlCLEVBQUU7NERBdUNuQjtBQVNEO0lBREMsaUJBQWlCLEVBQUU7d0RBd0JuQjtBQVNEO0lBREMsaUJBQWlCLEVBQUU7NERBNEJuQjtBQVFEO0lBREMsaUJBQWlCLEVBQUU7Z0RBaUJuQjtBQVFEO0lBREMsaUJBQWlCLEVBQUU7dURBa0JuQjtBQWNEO0lBREMsaUJBQWlCLEVBQUU7aUVBVW5COzRGQTd0QlUsbUJBQW1CO2tCQUQvQixVQUFVOzswQkFNTixNQUFNOzJCQUFDLFlBQVk7OzBCQUNuQixNQUFNOzJCQUFDLFVBQVU7eUNBd0RwQixrQkFBa0IsTUF1RGxCLEdBQUcsTUFzQ0gsT0FBTyxNQXFDUCxVQUFVLE1BNkJWLFFBQVEsTUF5QlIsT0FBTyxNQWlCUCxPQUFPLE1BdUJQLFVBQVUsTUF1QlYsTUFBTSxNQTZCTixNQUFNLE1BcUNDLE9BQU8sTUEwQ2QsTUFBTSxNQStCTixXQUFXLE1BMkJYLEtBQUssTUF3QkwsY0FBYyxNQThCZCxVQUFVLE1BMEJWLGlCQUFpQixNQStDakIsYUFBYSxNQWdDYixpQkFBaUIsTUFtQ2pCLEtBQUssTUF3QkwsWUFBWSxNQStCWixzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaWJlciwgY29tYmluZUxhdGVzdCwgZnJvbSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zYWN0aW9uLCBvcHRpb25zR2VuZXJhdG9yLCB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQ2xvc2VEYkNvbm5lY3Rpb24gfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IHsgQ3JlYXRlT2JqZWN0U3RvcmUsIERlbGV0ZU9iamVjdFN0b3JlLCBvcGVuRGF0YWJhc2UgfSBmcm9tICcuL25neC1pbmRleGVkLWRiJztcbmltcG9ydCB7XG4gIENPTkZJR19UT0tFTixcbiAgREJDb25maWcsXG4gIERCTW9kZSxcbiAgSU5ERVhFRF9EQixcbiAgS2V5LFxuICBPYmplY3RTdG9yZU1ldGEsXG4gIFJlcXVlc3RFdmVudCxcbiAgV2l0aElELFxufSBmcm9tICcuL25neC1pbmRleGVkLWRiLm1ldGEnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmd4SW5kZXhlZERCU2VydmljZSB7XG4gIHByaXZhdGUgZGVmYXVsdERhdGFiYXNlTmFtZT86IHN0cmluZyA9IG51bGw7XG4gIHByaXZhdGUgc2VsZWN0ZWREYjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ09ORklHX1RPS0VOKSBwcml2YXRlIGRiQ29uZmlnczogUmVjb3JkPHN0cmluZywgREJDb25maWc+LFxuICAgIEBJbmplY3QoSU5ERVhFRF9EQikgcHJpdmF0ZSBpbmRleGVkREI6IElEQkZhY3RvcnlcbiAgKSB7XG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLmRiQ29uZmlncykuZm9yRWFjaCgoZGJDb25maWcsIF8sIHJlZikgPT4gdGhpcy5pbnN0YW5jaWF0ZUNvbmZpZyhkYkNvbmZpZywgcmVmLmxlbmd0aCA9PT0gMSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnN0YW5jaWF0ZUNvbmZpZyhkYkNvbmZpZzogREJDb25maWcsIGlzT25seUNvbmZpZzogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghZGJDb25maWcubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZ3hJbmRleGVkREI6IFBsZWFzZSwgcHJvdmlkZSB0aGUgZGJOYW1lIGluIHRoZSBjb25maWd1cmF0aW9uJyk7XG4gICAgfVxuICAgIGlmICghZGJDb25maWcudmVyc2lvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZ3hJbmRleGVkREI6IFBsZWFzZSwgcHJvdmlkZSB0aGUgZGIgdmVyc2lvbiBpbiB0aGUgY29uZmlndXJhdGlvbicpO1xuICAgIH1cbiAgICBpZiAoKGRiQ29uZmlnLmlzRGVmYXVsdCA/PyBmYWxzZSkgJiYgdGhpcy5kZWZhdWx0RGF0YWJhc2VOYW1lKSB7XG4gICAgICAvLyBBIGRlZmF1bHQgREIgaXMgYWxyZWFkeSBjb25maWd1cmVkLCB0aHJvdyBhbiBlcnJvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZ3hJbmRleGVkREI6IE9ubHkgb25lIGRhdGFiYXNlIGNhbiBiZSBzZXQgYXMgZGVmYXVsdCcpO1xuICAgIH1cbiAgICBpZiAoKChkYkNvbmZpZy5pc0RlZmF1bHQgPz8gZmFsc2UpICYmICF0aGlzLmRlZmF1bHREYXRhYmFzZU5hbWUpIHx8IGlzT25seUNvbmZpZykge1xuICAgICAgdGhpcy5kZWZhdWx0RGF0YWJhc2VOYW1lID0gZGJDb25maWcubmFtZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWREYiA9IGRiQ29uZmlnLm5hbWU7XG4gICAgfVxuXG4gICAgYXdhaXQgQ3JlYXRlT2JqZWN0U3RvcmUoXG4gICAgICB0aGlzLmluZGV4ZWREQixcbiAgICAgIGRiQ29uZmlnLm5hbWUsXG4gICAgICBkYkNvbmZpZy52ZXJzaW9uLFxuICAgICAgZGJDb25maWcub2JqZWN0U3RvcmVzTWV0YSxcbiAgICAgIGRiQ29uZmlnLm1pZ3JhdGlvbkZhY3RvcnlcbiAgICApO1xuXG4gICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCBkYkNvbmZpZy5uYW1lKS50aGVuKChkYikgPT4ge1xuICAgICAgaWYgKGRiLnZlcnNpb24gIT09IGRiQ29uZmlnLnZlcnNpb24pIHtcbiAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBcbiAgICAgICAgICAgIFlvdXIgREIgQ29uZmlnIGRvZXNuJ3QgbWF0Y2ggdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlIERCIHdpdGggbmFtZSAke2RiQ29uZmlnLm5hbWV9LCBwbGVhc2UgdXBkYXRlIGl0XG4gICAgICAgICAgICBEQiBjdXJyZW50IHZlcnNpb246ICR7ZGIudmVyc2lvbn07XG4gICAgICAgICAgICBZb3VyIGNvbmZpZ3VyYXRpb246ICR7ZGJDb25maWcudmVyc2lvbn07XG4gICAgICAgICAgICBgKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFVzaW5nIGxhdGVzdCB2ZXJzaW9uICR7ZGIudmVyc2lvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRiQ29uZmlnc1tkYkNvbmZpZy5uYW1lXS52ZXJzaW9uID0gZGIudmVyc2lvbjtcbiAgICAgIH1cblxuICAgICAgZGIuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGRiQ29uZmlnKCk6IERCQ29uZmlnIHtcbiAgICByZXR1cm4gdGhpcy5kYkNvbmZpZ3NbdGhpcy5zZWxlY3RlZERiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gcmV0dXJuIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgZGF0YWJhc2VcbiAgICpcbiAgICogQFJldHVybiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIGRhdGFiYXNlIGFzIG51bWJlclxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgZ2V0RGF0YWJhc2VWZXJzaW9uKCk6IE9ic2VydmFibGU8bnVtYmVyIHwgc3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnMpID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYjogSURCRGF0YWJhc2UpID0+IHtcbiAgICAgICAgICBvYnMubmV4dChkYi52ZXJzaW9uKTtcbiAgICAgICAgICBvYnMuY29tcGxldGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IG9icy5lcnJvcihgZXJyb3IgZHVyaW5nIGdldCB2ZXJzaW9uIG9mIGRhdGFiYXNlID0+ICR7ZXJyfSBgKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBhIGRhdGFiYXNlIGZvciB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFiYXNlTmFtZT11bmRlZmluZWRdIERhdGFiYXNlIG5hbWUgdG8gc2VsZWN0LlxuICAgKi9cbiAgcHVibGljIHNlbGVjdERiKGRhdGFiYXNlTmFtZT86IHN0cmluZyk6IHZvaWQge1xuICAgIGRhdGFiYXNlTmFtZSA9IGRhdGFiYXNlTmFtZSA/PyB0aGlzLmRlZmF1bHREYXRhYmFzZU5hbWU7XG4gICAgaWYgKCFkYXRhYmFzZU5hbWUpIHtcbiAgICAgIC8vIE5hbWUgaXMgc3RpbGwgbnVsbCwgaXQgbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBkZWZhdWx0IGRhdGFiYXNlIHNldFxuICAgICAgLy8gYW5kIHRoZSBkYXRhYmFzZSBuYW1lIHdhcyBub3Qgc3BlY2lmaWVkIHdoaWxlIGNhbGxpbmcgYSBtZXRob2RcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGF0YWJhc2UgbmFtZSBzcGVjaWZpZWQgYW5kIG5vIGRlZmF1bHQgZGF0YWJhc2Ugc2V0LmApO1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuZGJDb25maWdzKS5pbmNsdWRlcyhkYXRhYmFzZU5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5neEluZGV4ZWREQjogRGF0YWJhc2UgJHtkYXRhYmFzZU5hbWV9IGlzIG5vdCBpbml0aWFsaXplZC5gKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGVkRGIgPSBkYXRhYmFzZU5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgc3RvcmUgYWQtaG9jXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0b3JlIHRvIGJlIGNyZWF0ZWRcbiAgICogQHBhcmFtIG1pZ3JhdGlvbkZhY3RvcnkgVGhlIG1pZ3JhdGlvbiBmYWN0b3J5IGlmIGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlT2JqZWN0U3RvcmUoXG4gICAgc3RvcmVTY2hlbWE6IE9iamVjdFN0b3JlTWV0YSxcbiAgICBtaWdyYXRpb25GYWN0b3J5PzogKCkgPT4geyBba2V5OiBudW1iZXJdOiAoZGI6IElEQkRhdGFiYXNlLCB0cmFuc2FjdGlvbjogSURCVHJhbnNhY3Rpb24pID0+IHZvaWQgfVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdG9yZVNjaGVtYXM6IE9iamVjdFN0b3JlTWV0YVtdID0gW3N0b3JlU2NoZW1hXTtcbiAgICBhd2FpdCBDcmVhdGVPYmplY3RTdG9yZShcbiAgICAgIHRoaXMuaW5kZXhlZERCLFxuICAgICAgdGhpcy5kYkNvbmZpZy5uYW1lLFxuICAgICAgKyt0aGlzLmRiQ29uZmlnLnZlcnNpb24sXG4gICAgICBzdG9yZVNjaGVtYXMsXG4gICAgICBtaWdyYXRpb25GYWN0b3J5XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG5ldyBlbnRyeSBpbiB0aGUgc3RvcmUgYW5kIHJldHVybnMgaXRzIGtleVxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBhZGQgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHZhbHVlIFRoZSBlbnRyeSB0byBiZSBhZGRlZFxuICAgKiBAcGFyYW0ga2V5IFRoZSBvcHRpb25hbCBrZXkgZm9yIHRoZSBlbnRyeVxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgYWRkPFQ+KHN0b3JlTmFtZTogc3RyaW5nLCB2YWx1ZTogVCwga2V5PzogYW55KTogT2JzZXJ2YWJsZTxUICYgV2l0aElEPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnMpID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYjogSURCRGF0YWJhc2UpID0+IHtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgZGIsXG4gICAgICAgICAgICBvcHRpb25zR2VuZXJhdG9yKERCTW9kZS5yZWFkd3JpdGUsIHN0b3JlTmFtZSwgKGUpID0+IG9icy5lcnJvcihlKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0OiBJREJSZXF1ZXN0PElEQlZhbGlkS2V5PiA9IEJvb2xlYW4oa2V5KSA/IG9iamVjdFN0b3JlLmFkZCh2YWx1ZSwga2V5KSA6IG9iamVjdFN0b3JlLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGFzeW5jIChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IChldnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IGdldFJlcXVlc3Q6IElEQlJlcXVlc3QgPSBvYmplY3RTdG9yZS5nZXQocmVzdWx0KSBhcyBJREJSZXF1ZXN0PFQ+O1xuICAgICAgICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9icy5uZXh0KChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxUICYgV2l0aElEPikucmVzdWx0KTtcbiAgICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9icy5lcnJvcihldmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvYnMuZXJyb3IoZXZlbnQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IG9icy5lcnJvcihlcnJvcikpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbmV3IGVudHJpZXMgaW4gdGhlIHN0b3JlIGFuZCByZXR1cm5zIGl0cyBrZXlcbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gYWRkIHRoZSBpdGVtXG4gICAqIEBwYXJhbSB2YWx1ZXMgVGhlIGVudHJpZXMgdG8gYmUgYWRkZWQgY29udGFpbmluZyBvcHRpb25hbCBrZXkgYXR0cmlidXRlXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBidWxrQWRkPFQ+KHN0b3JlTmFtZTogc3RyaW5nLCB2YWx1ZXM6IEFycmF5PFQgJiB7IGtleT86IGFueSB9Pik6IE9ic2VydmFibGU8bnVtYmVyW10+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IG5ldyBQcm9taXNlPG51bWJlcltdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGI6IElEQkRhdGFiYXNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbihkYiwgb3B0aW9uc0dlbmVyYXRvcihEQk1vZGUucmVhZHdyaXRlLCBzdG9yZU5hbWUsIHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPG51bWJlcj4oKHJlc29sdmUxLCByZWplY3QxKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IHZhbHVlLmtleTtcbiAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlLmtleTtcblxuICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0OiBJREJSZXF1ZXN0PElEQlZhbGlkS2V5PiA9IEJvb2xlYW4oa2V5KVxuICAgICAgICAgICAgICAgID8gb2JqZWN0U3RvcmUuYWRkKHZhbHVlLCBrZXkpXG4gICAgICAgICAgICAgICAgOiBvYmplY3RTdG9yZS5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoZXZ0LnRhcmdldCBhcyBJREJPcGVuREJSZXF1ZXN0KS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZTEoKHJlc3VsdCBhcyB1bmtub3duKSBhcyBudW1iZXIpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXNvbHZlKFByb21pc2UuYWxsKHJlc3VsdHMpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IHJlamVjdChyZWFzb24pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmcm9tKHByb21pc2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgZW50cmllcyBpbiB0aGUgc3RvcmUgYW5kIHJldHVybnMgY3VycmVudCBlbnRyaWVzIGluIHRoZSBzdG9yZVxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBhZGQgdGhlIGl0ZW1cbiAgICogQHBhcmFtIGtleXMgVGhlIGtleXMgdG8gYmUgZGVsZXRlZFxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgYnVsa0RlbGV0ZShzdG9yZU5hbWU6IHN0cmluZywga2V5czogS2V5W10pOiBPYnNlcnZhYmxlPG51bWJlcltdPiB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBrZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8bnVtYmVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgICAgLnRoZW4oKGRiOiBJREJEYXRhYmFzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbihkYiwgb3B0aW9uc0dlbmVyYXRvcihEQk1vZGUucmVhZHdyaXRlLCBzdG9yZU5hbWUsIHJlamVjdCwgcmVzb2x2ZSkpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgICAgb2JqZWN0U3RvcmUuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZ2V0QWxsKHN0b3JlTmFtZSlcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKG5ld1ZhbHVlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXdWYWx1ZXMgYXMgYW55KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4gcmVqZWN0KHJlYXNvbikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZyb20oUHJvbWlzZS5hbGwocHJvbWlzZXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVudHJ5IGJ5IGtleS5cbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gcXVlcnlcbiAgICogQHBhcmFtIGtleSBUaGUgZW50cnkga2V5XG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRCeUtleTxUPihzdG9yZU5hbWU6IHN0cmluZywga2V5OiBJREJWYWxpZEtleSk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxUPigob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGI6IElEQkRhdGFiYXNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbihkYiwgb3B0aW9uc0dlbmVyYXRvcihEQk1vZGUucmVhZG9ubHksIHN0b3JlTmFtZSwgb2JzLmVycm9yKSk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBvYmplY3RTdG9yZS5nZXQoa2V5KSBhcyBJREJSZXF1ZXN0PFQ+O1xuICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgb2JzLm5leHQoKGV2ZW50LnRhcmdldCBhcyBJREJSZXF1ZXN0PFQ+KS5yZXN1bHQpO1xuICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvYnMuZXJyb3IoZXZlbnQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IG9icy5lcnJvcihlcnJvcikpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIG11bHRpcGxlIGVudHJpZXMgaW4gdGhlIHN0b3JlXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0b3JlIHRvIHJldHJpZXZlIHRoZSBpdGVtc1xuICAgKiBAcGFyYW0ga2V5cyBUaGUgaWRzIGVudHJpZXMgdG8gYmUgcmV0cmlldmVcbiAgICovXG4gIEBDbG9zZURiQ29ubmVjdGlvbigpXG4gIGJ1bGtHZXQ8VD4oc3RvcmVOYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PElEQlZhbGlkS2V5Pik6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZXMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLmdldEJ5S2V5PFQ+KHN0b3JlTmFtZSwga2V5KSk7XG5cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9icykgPT4ge1xuICAgICAgY29tYmluZUxhdGVzdChvYnNlcnZhYmxlcykuc3Vic2NyaWJlKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgb2JzLm5leHQodmFsdWVzKTtcbiAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVudHJ5IGJ5IGlkLlxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBxdWVyeVxuICAgKiBAcGFyYW0gaWQgVGhlIGVudHJ5IGlkXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRCeUlEPFQ+KHN0b3JlTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nIHwgbnVtYmVyKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnMpID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYjogSURCRGF0YWJhc2UpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oZGIsIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWRvbmx5LCBzdG9yZU5hbWUsIG9icy5lcnJvciwgb2JzLm5leHQpKTtcbiAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdDogSURCUmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldChpZCkgYXMgSURCUmVxdWVzdDxUPjtcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9icy5uZXh0KChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxUPikucmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBvYnMuZXJyb3IoZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVudHJ5IGJ5IGluZGV4LlxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBxdWVyeVxuICAgKiBAcGFyYW0gaW5kZXhOYW1lIFRoZSBpbmRleCBuYW1lIHRvIGZpbHRlclxuICAgKiBAcGFyYW0ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRCeUluZGV4PFQ+KHN0b3JlTmFtZTogc3RyaW5nLCBpbmRleE5hbWU6IHN0cmluZywga2V5OiBJREJWYWxpZEtleSk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oZGIsIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWRvbmx5LCBzdG9yZU5hbWUsIG9icy5lcnJvcikpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9iamVjdFN0b3JlLmluZGV4KGluZGV4TmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4LmdldChrZXkpIGFzIElEQlJlcXVlc3Q8VD47XG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvYnMubmV4dCgoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3Q8VD4pLnJlc3VsdCk7XG4gICAgICAgICAgICBvYnMuY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4gb2JzLmVycm9yKHJlYXNvbikpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgZWxlbWVudHMgZnJvbSBvbmUgc3RvcmVcbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gc2VsZWN0IHRoZSBpdGVtc1xuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgZ2V0QWxsPFQ+KHN0b3JlTmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9icykgPT4ge1xuICAgICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCB0aGlzLmRiQ29uZmlnLm5hbWUsIHRoaXMuZGJDb25maWcudmVyc2lvbilcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgICAgdmFsaWRhdGVCZWZvcmVUcmFuc2FjdGlvbihkYiwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uKGRiLCBvcHRpb25zR2VuZXJhdG9yKERCTW9kZS5yZWFkb25seSwgc3RvcmVOYW1lLCBvYnMuZXJyb3IsIG9icy5uZXh0KSk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXG4gICAgICAgICAgY29uc3QgcmVxdWVzdDogSURCUmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldEFsbCgpO1xuXG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2dDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9icy5lcnJvcihldnQpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICh7IHRhcmdldDogeyByZXN1bHQ6IFJlc3VsdEFsbCB9IH06IFJlcXVlc3RFdmVudDxUPikgPT4ge1xuICAgICAgICAgICAgb2JzLm5leHQoUmVzdWx0QWxsIGFzIFRbXSk7XG4gICAgICAgICAgICBvYnMuY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBvYnMuZXJyb3IoZXJyb3IpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSByZWNvcmQgaW4gc3RvcmUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgYW5kIGtleS4gUmV0dXJuIGFsbCBpdGVtcyBwcmVzZW50IGluIHRoZSBzdG9yZVxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBlbnRyeVxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgdXBkYXRlPFQ+KHN0b3JlTmFtZTogc3RyaW5nLCB2YWx1ZTogVCk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWR3cml0ZSwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXG4gICAgICAgICAgY29uc3QgcmVxdWVzdDogSURCUmVxdWVzdDxJREJWYWxpZEtleT4gPSBvYmplY3RTdG9yZS5wdXQodmFsdWUpO1xuXG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBhc3luYyAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSAoZXZ0LnRhcmdldCBhcyBJREJPcGVuREJSZXF1ZXN0KS5yZXN1bHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGdldFJlcXVlc3Q6IElEQlJlcXVlc3QgPSBvYmplY3RTdG9yZS5nZXQocmVzdWx0KSBhcyBJREJSZXF1ZXN0PFQ+O1xuICAgICAgICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIG9icy5uZXh0KChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxUICYgV2l0aElEPikucmVzdWx0KTtcbiAgICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiBvYnMuZXJyb3IocmVhc29uKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGEgcmVjb3JkIGluIHN0b3JlIHdpdGggdGhlIGdpdmVuIHZhbHVlIGFuZCBrZXkuIFJldHVybiBhbGwgaXRlbXMgcHJlc2VudCBpbiB0aGUgc3RvcmVcbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBpdGVtcyBUaGUgdmFsdWVzIHRvIHVwZGF0ZSBpbiB0aGUgREJcbiAgICpcbiAgICogQFJldHVybiBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIE9ic2VydmFibGUgd2l0aCB0aGUgcHJpbWFyeSBrZXkgb2YgdGhlIG9iamVjdCB0aGF0IHdhcyBsYXN0IGluIGdpdmVuIGFycmF5XG4gICAqXG4gICAqIEBlcnJvciBJZiB0aGUgY2FsbCB0byBidWxrUHV0IGZhaWxzIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGFib3J0ZWQgYW5kIHByZXZpb3VzbHkgaW5zZXJ0ZWQgZW50aXRpZXMgd2lsbCBiZSBkZWxldGVkXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBwdWJsaWMgYnVsa1B1dDxUPihzdG9yZU5hbWU6IHN0cmluZywgaXRlbXM6IEFycmF5PFQ+KTogT2JzZXJ2YWJsZTxLZXk+IHtcbiAgICBsZXQgdHJhbnNhY3Rpb246IElEQlRyYW5zYWN0aW9uO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWR3cml0ZSwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuXG4gICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdDogSURCUmVxdWVzdDxJREJWYWxpZEtleT4gPSBvYmplY3RTdG9yZS5wdXQoaXRlbSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAgICAgICAgICAgICAgb2JzLm5leHQoKGV2dC50YXJnZXQgYXMgSURCUmVxdWVzdDxLZXk+KS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIG9icy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgICAgICAgICBvYnMuZXJyb3IoZXZ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24/LmFib3J0KCk7XG4gICAgICAgICAgb2JzLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGl0ZW1zIGZyb20gdGhlIHN0b3JlIGFmdGVyIGRlbGV0ZS5cbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gaGF2ZSB0aGUgZW50cnkgZGVsZXRlZFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGJlIGRlbGV0ZWRcbiAgICovXG4gIEBDbG9zZURiQ29ubmVjdGlvbigpXG4gIGRlbGV0ZTxUPihzdG9yZU5hbWU6IHN0cmluZywga2V5OiBLZXkpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWR3cml0ZSwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgIG9iamVjdFN0b3JlLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QWxsKHN0b3JlTmFtZSlcbiAgICAgICAgICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAgICAgLnN1YnNjcmliZSgobmV3VmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JzLm5leHQobmV3VmFsdWVzIGFzIFRbXSk7XG4gICAgICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiBvYnMuZXJyb3IocmVhc29uKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGZyb20gdGhlIHN0b3JlIGFmdGVyIGEgc3VjY2Vzc2Z1bCBkZWxldGUuXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0b3JlIHRvIGhhdmUgdGhlIGVudHJ5IGRlbGV0ZWRcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBiZSBkZWxldGVkXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBkZWxldGVCeUtleShzdG9yZU5hbWU6IHN0cmluZywga2V5OiBLZXkpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9icykgPT4ge1xuICAgICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCB0aGlzLmRiQ29uZmlnLm5hbWUsIHRoaXMuZGJDb25maWcudmVyc2lvbilcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgICAgdmFsaWRhdGVCZWZvcmVUcmFuc2FjdGlvbihkYiwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uKFxuICAgICAgICAgICAgZGIsXG4gICAgICAgICAgICBvcHRpb25zR2VuZXJhdG9yKERCTW9kZS5yZWFkd3JpdGUsIHN0b3JlTmFtZSwgKGUpID0+IG9icy5lcnJvcihlKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcblxuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYnMubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIG9icy5jb21wbGV0ZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBvYmplY3RTdG9yZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IG9icy5lcnJvcihyZWFzb24pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc3VjY2Vzc2Z1bGx5IGRlbGV0ZSBhbGwgZW50cmllcyBmcm9tIHRoZSBzdG9yZS5cbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gaGF2ZSB0aGUgZW50cmllcyBkZWxldGVkXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBjbGVhcihzdG9yZU5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWR3cml0ZSwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgIG9iamVjdFN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9icy5uZXh0KHRydWUpO1xuICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IG9icy5lcnJvcihyZWFzb24pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc3VjY2Vzc2Z1bGx5IGRlbGV0ZSB0aGUgREIuXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBkZWxldGVEYXRhYmFzZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9icykgPT4ge1xuICAgICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCB0aGlzLmRiQ29uZmlnLm5hbWUsIHRoaXMuZGJDb25maWcudmVyc2lvbilcbiAgICAgICAgLnRoZW4oYXN5bmMgKGRiKSA9PiB7XG4gICAgICAgICAgYXdhaXQgZGIuY2xvc2UoKTtcbiAgICAgICAgICBjb25zdCBkZWxldGVEQlJlcXVlc3QgPSB0aGlzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmRiQ29uZmlnLm5hbWUpO1xuICAgICAgICAgIGRlbGV0ZURCUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBvYnMubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIG9icy5jb21wbGV0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZGVsZXRlREJSZXF1ZXN0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IG9icy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgZGVsZXRlREJSZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ0RlbGV0ZSBibG9ja2VkOiBFbnN1cmUgYWxsIHRhYnMsIGluc3RhbmNlcywgb3IgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC4gRGF0YWJhc2UgbmFtZTonLFxuICAgICAgICAgICAgICB0aGlzLmRiQ29uZmlnLm5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvYnMuZXJyb3IobmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlbGV0ZSBkYXRhYmFzZSBiZWNhdXNlIGl0J3MgYmxvY2tlZFwiKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gb2JzLmVycm9yKGVycm9yKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BlbiBjdXJzb3IgZXZlbnRcbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gaGF2ZSB0aGUgZW50cmllcyBkZWxldGVkXG4gICAqIEBwYXJhbSBrZXlSYW5nZSBUaGUga2V5IHJhbmdlIHdoaWNoIHRoZSBjdXJzb3Igc2hvdWxkIGJlIG9wZW4gb25cbiAgICogQHBhcmFtIGRpcmVjdGlvbiBBIHN0cmluZyB0ZWxsaW5nIHRoZSBjdXJzb3Igd2hpY2ggZGlyZWN0aW9uIHRvIHRyYXZlbC4gVGhlIGRlZmF1bHQgaXMgbmV4dFxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgb3BlbkN1cnNvcihzdG9yZU5hbWU6IHN0cmluZywga2V5UmFuZ2U/OiBJREJLZXlSYW5nZSwgZGlyZWN0aW9uOiBJREJDdXJzb3JEaXJlY3Rpb24gPSAnbmV4dCcpOiBPYnNlcnZhYmxlPEV2ZW50PiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnMpID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICAgIHZhbGlkYXRlQmVmb3JlVHJhbnNhY3Rpb24oZGIsIHN0b3JlTmFtZSwgKGUpID0+IG9icy5lcnJvcihlKSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbihkYiwgb3B0aW9uc0dlbmVyYXRvcihEQk1vZGUucmVhZHdyaXRlLCBzdG9yZU5hbWUsIG9icy5lcnJvcikpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ID1cbiAgICAgICAgICAgIGtleVJhbmdlID09PSB1bmRlZmluZWQgPyBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKCkgOiBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvYnMubmV4dChldmVudCk7XG4gICAgICAgICAgICBvYnMuY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4gb2JzLmVycm9yKHJlYXNvbikpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gYSBjdXJzb3IgYnkgaW5kZXggZmlsdGVyLlxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIGluZGV4TmFtZSBUaGUgaW5kZXggbmFtZSB0byBmaWx0ZXIuXG4gICAqIEBwYXJhbSBrZXlSYW5nZSBUaGUgcmFuZ2UgdmFsdWUgYW5kIGNyaXRlcmlhIHRvIGFwcGx5IG9uIHRoZSBpbmRleC5cbiAgICovXG4gIEBDbG9zZURiQ29ubmVjdGlvbigpXG4gIG9wZW5DdXJzb3JCeUluZGV4KFxuICAgIHN0b3JlTmFtZTogc3RyaW5nLFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGtleVJhbmdlOiBJREJLZXlSYW5nZSxcbiAgICBkaXJlY3Rpb246IElEQkN1cnNvckRpcmVjdGlvbiA9ICduZXh0JyxcbiAgICBtb2RlOiBEQk1vZGUgPSBEQk1vZGUucmVhZG9ubHlcbiAgKTogT2JzZXJ2YWJsZTxFdmVudD4ge1xuICAgIGNvbnN0IG9icyA9IG5ldyBTdWJqZWN0PEV2ZW50PigpO1xuXG4gICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCB0aGlzLmRiQ29uZmlnLm5hbWUsIHRoaXMuZGJDb25maWcudmVyc2lvbilcbiAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChyZWFzb24pID0+IHtcbiAgICAgICAgICBvYnMuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oXG4gICAgICAgICAgZGIsXG4gICAgICAgICAgb3B0aW9uc0dlbmVyYXRvcihcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBzdG9yZU5hbWUsXG4gICAgICAgICAgICAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgIG9icy5lcnJvcihyZWFzb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgb2JzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleChpbmRleE5hbWUpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXgub3BlbkN1cnNvcihrZXlSYW5nZSwgZGlyZWN0aW9uKTtcblxuICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICBvYnMubmV4dChldmVudCk7XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWFzb24pID0+IG9icy5lcnJvcihyZWFzb24pKTtcblxuICAgIHJldHVybiBvYnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgaXRlbXMgYnkgYW4gaW5kZXguXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0b3JlIHRvIHF1ZXJ5XG4gICAqIEBwYXJhbSBpbmRleE5hbWUgVGhlIGluZGV4IG5hbWUgdG8gZmlsdGVyXG4gICAqIEBwYXJhbSBrZXlSYW5nZSAgVGhlIHJhbmdlIHZhbHVlIGFuZCBjcml0ZXJpYSB0byBhcHBseSBvbiB0aGUgaW5kZXguXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRBbGxCeUluZGV4PFQ+KHN0b3JlTmFtZTogc3RyaW5nLCBpbmRleE5hbWU6IHN0cmluZywga2V5UmFuZ2U6IElEQktleVJhbmdlKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICBjb25zdCBkYXRhOiBUW10gPSBbXTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9icykgPT4ge1xuICAgICAgb3BlbkRhdGFiYXNlKHRoaXMuaW5kZXhlZERCLCB0aGlzLmRiQ29uZmlnLm5hbWUsIHRoaXMuZGJDb25maWcudmVyc2lvbilcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgICAgdmFsaWRhdGVCZWZvcmVUcmFuc2FjdGlvbihkYiwgc3RvcmVOYW1lLCAoZSkgPT4gb2JzLmVycm9yKGUpKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uKGRiLCBvcHRpb25zR2VuZXJhdG9yKERCTW9kZS5yZWFkb25seSwgc3RvcmVOYW1lLCBvYnMuZXJyb3IpKTtcbiAgICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleChpbmRleE5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleC5vcGVuQ3Vyc29yKGtleVJhbmdlKTtcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yOiBJREJDdXJzb3JXaXRoVmFsdWUgPSAoZXZlbnQudGFyZ2V0IGFzIElEQlJlcXVlc3Q8SURCQ3Vyc29yV2l0aFZhbHVlPikucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICBkYXRhLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYnMubmV4dChkYXRhKTtcbiAgICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IG9icy5lcnJvcihyZWFzb24pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBwcmltYXJ5IGtleXMgYnkgYW4gaW5kZXguXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0b3JlIHRvIHF1ZXJ5XG4gICAqIEBwYXJhbSBpbmRleE5hbWUgVGhlIGluZGV4IG5hbWUgdG8gZmlsdGVyXG4gICAqIEBwYXJhbSBrZXlSYW5nZSAgVGhlIHJhbmdlIHZhbHVlIGFuZCBjcml0ZXJpYSB0byBhcHBseSBvbiB0aGUgaW5kZXguXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRBbGxLZXlzQnlJbmRleChcbiAgICBzdG9yZU5hbWU6IHN0cmluZyxcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBrZXlSYW5nZTogSURCS2V5UmFuZ2VcbiAgKTogT2JzZXJ2YWJsZTx7IHByaW1hcnlLZXk6IGFueTsga2V5OiBhbnkgfVtdPiB7XG4gICAgY29uc3QgZGF0YTogeyBwcmltYXJ5S2V5OiBhbnk7IGtleTogYW55IH1bXSA9IFtdO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oZGIsIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWRvbmx5LCBzdG9yZU5hbWUsIG9icy5lcnJvcikpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9iamVjdFN0b3JlLmluZGV4KGluZGV4TmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGluZGV4Lm9wZW5LZXlDdXJzb3Ioa2V5UmFuZ2UpO1xuICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3I6IElEQkN1cnNvciA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdDxJREJDdXJzb3I+KS5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgIGRhdGEucHVzaCh7IHByaW1hcnlLZXk6IGN1cnNvci5wcmltYXJ5S2V5LCBrZXk6IGN1cnNvci5rZXkgfSk7XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JzLm5leHQoZGF0YSk7XG4gICAgICAgICAgICAgIG9icy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiBvYnMuZXJyb3IocmVhc29uKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gYSBzdG9yZS5cbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gcXVlcnlcbiAgICogQHBhcmFtIGtleVJhbmdlICBUaGUgcmFuZ2UgdmFsdWUgYW5kIGNyaXRlcmlhIHRvIGFwcGx5LlxuICAgKi9cbiAgQENsb3NlRGJDb25uZWN0aW9uKClcbiAgY291bnQoc3RvcmVOYW1lOiBzdHJpbmcsIGtleVJhbmdlPzogSURCVmFsaWRLZXkgfCBJREJLZXlSYW5nZSk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnMpID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICAgIHZhbGlkYXRlQmVmb3JlVHJhbnNhY3Rpb24oZGIsIHN0b3JlTmFtZSwgKGUpID0+IG9icy5lcnJvcihlKSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBjcmVhdGVUcmFuc2FjdGlvbihkYiwgb3B0aW9uc0dlbmVyYXRvcihEQk1vZGUucmVhZG9ubHksIHN0b3JlTmFtZSwgb2JzLmVycm9yKSk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3Q6IElEQlJlcXVlc3QgPSBvYmplY3RTdG9yZS5jb3VudChrZXlSYW5nZSk7XG4gICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGUpID0+IG9icy5lcnJvcihlKTtcbiAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChlKSA9PiB7XG4gICAgICAgICAgICBvYnMubmV4dCgoKGUudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdCBhcyB1bmtub3duKSBhcyBudW1iZXIpO1xuICAgICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChyZWFzb24pID0+IG9icy5lcnJvcihyZWFzb24pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiBhIHN0b3JlLlxuICAgKiBAcGFyYW0gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZSB0byBxdWVyeVxuICAgKiBAcGFyYW0ga2V5UmFuZ2UgIFRoZSByYW5nZSB2YWx1ZSBhbmQgY3JpdGVyaWEgdG8gYXBwbHkuXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBjb3VudEJ5SW5kZXgoc3RvcmVOYW1lOiBzdHJpbmcsIGluZGV4TmFtZTogc3RyaW5nLCBrZXlSYW5nZT86IElEQlZhbGlkS2V5IHwgSURCS2V5UmFuZ2UpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzKSA9PiB7XG4gICAgICBvcGVuRGF0YWJhc2UodGhpcy5pbmRleGVkREIsIHRoaXMuZGJDb25maWcubmFtZSwgdGhpcy5kYkNvbmZpZy52ZXJzaW9uKVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgICB2YWxpZGF0ZUJlZm9yZVRyYW5zYWN0aW9uKGRiLCBzdG9yZU5hbWUsIChlKSA9PiBvYnMuZXJyb3IoZSkpO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb24oZGIsIG9wdGlvbnNHZW5lcmF0b3IoREJNb2RlLnJlYWRvbmx5LCBzdG9yZU5hbWUsIG9icy5lcnJvcikpO1xuICAgICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IG9iamVjdFN0b3JlLmluZGV4KGluZGV4TmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdDogSURCUmVxdWVzdCA9IGluZGV4LmNvdW50KGtleVJhbmdlKTtcbiAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZSkgPT4gb2JzLmVycm9yKGUpO1xuICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGUpID0+IHtcbiAgICAgICAgICAgIG9icy5uZXh0KCgoZS50YXJnZXQgYXMgSURCT3BlbkRCUmVxdWVzdCkucmVzdWx0IGFzIHVua25vd24pIGFzIG51bWJlcik7XG4gICAgICAgICAgICBvYnMuY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4gb2JzLmVycm9yKHJlYXNvbikpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgc3RvcmUgYnkgbmFtZS5cbiAgICogQHBhcmFtIHN0b3JlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RvcmUgdG8gcXVlcnlcbiAgICovXG4gIGRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIERlbGV0ZU9iamVjdFN0b3JlKHRoaXMuZGJDb25maWcubmFtZSwgKyt0aGlzLmRiQ29uZmlnLnZlcnNpb24sIHN0b3JlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBvYmplY3Qgc3RvcmUgbmFtZXMuXG4gICAqL1xuICBAQ2xvc2VEYkNvbm5lY3Rpb24oKVxuICBnZXRBbGxPYmplY3RTdG9yZU5hbWVzKCk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9iczogU3Vic2NyaWJlcjxzdHJpbmdbXT4pOiB2b2lkID0+IHtcbiAgICAgIG9wZW5EYXRhYmFzZSh0aGlzLmluZGV4ZWREQiwgdGhpcy5kYkNvbmZpZy5uYW1lLCB0aGlzLmRiQ29uZmlnLnZlcnNpb24pXG4gICAgICAgIC50aGVuKChkYjogSURCRGF0YWJhc2UpOiB2b2lkID0+IHtcbiAgICAgICAgICBvYnMubmV4dChbLi4uKChkYi5vYmplY3RTdG9yZU5hbWVzIGFzIHVua25vd24pIGFzIEl0ZXJhYmxlPHN0cmluZz4pXSk7XG4gICAgICAgICAgb2JzLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgocmVhc29uOiB1bmtub3duKTogdm9pZCA9PiBvYnMuZXJyb3IocmVhc29uKSk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==